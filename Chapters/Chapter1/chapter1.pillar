!!Introduction
@intro

This booklet is about object-centric instrumentation in Pharo. An instrumentation is object-centric if it applies to one specific object (or a set of objects), without consideration of its class. It means the instrumentation can be applied on one object, leaving untouched all other instances of its class, or to an heterogeneous set of instances of different classes. This booklet gives an overview of available object-centric instrumentation techniques in Pharo, either present in the standard distribution or available on download. We only focus on object-centric state-access instrumentation, which is a particular case of object-centric instrumentation. We will not go into deep technical usage description, nor into implementation details. Each chapter illustrates one solution with examples, and gives the necessary references if one wants to go deeper in the study of the solution. We study each technique following a three-fold evaluation. First, the studied technique is applied on a simple example of object-centric instrumentation. Second, the technique is evaluated against a set of desirable properties. Finally, performance overhead are evaluated. Only the raw solution is evaluated, without considering the possibility of enhancing the technique by building something on top.

This chapter presents the three-fold evaluation applied to each studied technique, based on the current stable Pharo 7. Each time, a new Pharo image is created, the evaluation code is loaded as well as the studied solution's packages if needed. Then the evaluation is performed. The evaluation code presented in this chapter is available on Github at the following address:

https://github.com/StevenCostiou/PharoObjectCentricEvaluationExamples

!!!Illustration example
%*@example-model*
%label=example-model|caption=The ==Person== class|language=Smalltalk|lineNumber=true
Each studied solution is experimented on an example of object-centric behavior instrumentation. We use a class ==Person== defined in the following script. This class has a ==name== instance variable and a ==name:== method. This method stores the parameter it is given into the instance variable. We would like that each time a value is stored in that instance variable, that value is printed on the ==Transcript==.

[[[
Person >> name: aName
    name := aName
]]]

The instrumentation can be defined as follows, if ==aName== is the reference to the value being stored in the ==name== instance variable of the ==Person== instance:
[[[
aName logCr
]]]

The evaluation example is defined in the following script. Two instances ==p1== and ==p2== of class ==Person== are created, and object-centric instrumentation must be applied to the ==p2== instance. Then each of these instances is given a name through a call to the ==name:== method. The result must be that ==p2== prints its name in the ==Transcript==, while nothing must happen for ==p1==.
%*@motivation-example*
%label=motivation-example|caption=Evaluation example for object-centric instrumentation|language=Smalltalk|lineNumber=true
[[[
  |p1 p2|
  p1 := Person new.
  p2 := Person new.
  "Instrumentation must be applied to p2 here"
  p1 name: 'Worf'.
  p2 name: 'Dax'.
  "Only 'Dax' prints in the Transcript"
]]]

!!!Evaluation criteria

Each solution is evaluated against the following desirable properties.

|!Property|!Definition
|Manipulated entity|The unit of instrumentation
| |(''e.g.'' a class, a Trait, an object...)
|Reusability|The entity can be reused to instrument different objects
|Flexibility|Instrumentation does not put constraint on the
| | source code or in the coding style
|Granularity|The level of at which behavior can be instrumented
| |(''e.g.'' method, AST...)
|Integration|Instrumentation does not break system features


!!!Performance overhead evaluation

To provide a approximation of the performance overhead due to instrumentation, we compare the execution time of a block of code without instrumentation with the execution time of an instrumented block of code. The method ==evaluateOverheadFor:== from the following script shows how the average execution time is computed. The parameter is an instance of ==Person== that is either not instrumented (''i.e.'' to compute the reference execution time used for comparison) or instrumented by one of the studied techniques. The ==#name:== message is sent a thousand times to the ==Person== instance and each time the execution time is recorded. An average of all the execution times is computed and returned by the method. This average time is used to compare execution time of an instrumented instance against the execution time of a non-instrumented instance.

%label=performance-overhead-method|caption=Performance overhead evaluation script|language=Smalltalk|lineNumber=true
%*@performance-overhead-method*
[[[
evaluateOverheadFor: aPerson
  |execTimes|
  execTimes := OrderedCollection new.
  1 to: 1000 do:[:i|
    execTimes add: [aPerson name: i] timeToRun].
  ^execTimes average
]]]

!!!Structure of the book
The second chapter will provide an overview of the evaluation results of object-centric instrumentation techniques available in Pharo. A reader may directly read this chapter if he is already familiar with the Pharo techniques presented in the book. Chapters 3 to 7 describe five solutions for object-centric instrumentation, and provide an evaluation of these solutions. Chapter 8 drafts the premises of an object-centric debugger and concludes the book.
