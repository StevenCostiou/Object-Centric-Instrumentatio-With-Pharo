% -*- mode: latex; -*- mustache tags:  
\documentclass[10pt,twoside,english]{_support/latex/sbabook/sbabook}
\let\wholebook=\relax

\usepackage{import}
\subimport{_support/latex/}{common.tex}

%=================================================================
% Debug packages for page layout and overfull lines
% Remove the showtrims document option before printing
\ifshowtrims
  \usepackage{showframe}
  \usepackage[color=magenta,width=5mm]{_support/latex/overcolored}
\fi


% =================================================================
\title{Object-Centric Instrumentation with Pharo}
\author{Steven Costiou}
\series{Square Bracket tutorials}

\hypersetup{
  pdftitle = {Object-Centric Instrumentation with Pharo},
  pdfauthor = {Steven Costiou},
  pdfkeywords = {object-centric, meta-programming}
}


% =================================================================
\begin{document}

% Title page and colophon on verso
\maketitle
\pagestyle{titlingpage}
\thispagestyle{titlingpage} % \pagestyle does not work on the first one…

\cleartoverso
{\small

  Copyright 2017 by Steven Costiou.

  The contents of this book are protected under the Creative Commons
  Attribution-ShareAlike 3.0 Unported license.

  You are \textbf{free}:
  \begin{itemize}
  \item to \textbf{Share}: to copy, distribute and transmit the work,
  \item to \textbf{Remix}: to adapt the work,
  \end{itemize}

  Under the following conditions:
  \begin{description}
  \item[Attribution.] You must attribute the work in the manner specified by the
    author or licensor (but not in any way that suggests that they endorse you
    or your use of the work).
  \item[Share Alike.] If you alter, transform, or build upon this work, you may
    distribute the resulting work only under the same, similar or a compatible
    license.
  \end{description}

  For any reuse or distribution, you must make clear to others the
  license terms of this work. The best way to do this is with a link to
  this web page: \\
  \url{http://creativecommons.org/licenses/by-sa/3.0/}

  Any of the above conditions can be waived if you get permission from
  the copyright holder. Nothing in this license impairs or restricts the
  author's moral rights.

  \begin{center}
    \includegraphics[width=0.2\textwidth]{_support/latex/sbabook/CreativeCommons-BY-SA.pdf}
  \end{center}

  Your fair dealing and other rights are in no way affected by the
  above. This is a human-readable summary of the Legal Code (the full
  license): \\
  \url{http://creativecommons.org/licenses/by-sa/3.0/legalcode}

  \vfill

  % Publication info would go here (publisher, ISBN, cover design…)
  Layout and typography based on the \textcode{sbabook} \LaTeX{} class by Damien
  Pollet.
}


\frontmatter
\pagestyle{plain}

\tableofcontents*
\clearpage\listoffigures

\mainmatter

\chapter{Introduction}
This booklet is about object-centric instrumentation in Pharo. An instrumentation is object-centric if it applies to one specific object (or a set of objects), without consideration of its class. It means the instrumentation can be applied on one object, leaving untouched all other instances of its class, or to an heterogeneous set of instances of different classes. This booklet gives an overview of available object-centric instrumentation techniques in Pharo, either present in the standard distribution or available on download. We only focus on object-centric state-access instrumentation, which is a particular case of object-centric instrumentation. We will not go into deep technical usage description, nor into implementation details. Each chapter illustrates one solution with examples, and gives the necessary references if one wants to go deeper in the study of the solution. We study each technique following a three-fold evaluation. First, the studied technique is applied on a simple example of object-centric instrumentation. Second, the technique is evaluated against a set of desirable properties. Finally, performance overhead are evaluated. Only the raw solution is evaluated, without considering the possibility of enhancing the technique by building something on top.

This chapter presents the three-fold evaluation applied to each studied technique, based on the current stable Pharo 7. Each time, a new Pharo image is created, the evaluation code is loaded as well as the studied solution's packages if needed. Then the evaluation is performed. The evaluation code presented in this chapter is available on Github at the following address:

https://github.com/StevenCostiou/PharoObjectCentricEvaluationExamples
\section{Illustration example}
Each studied solution is experimented on an example of object-centric behavior instrumentation. We use a class \textcode{Person} defined in the following script. This class has a \textcode{name} instance variable and a \textcode{name:} method. This method stores the parameter it is given into the instance variable. We would like that each time a value is stored in that instance variable, that value is printed on the \textcode{Transcript}.

\begin{displaycode}{plain}
Person >> name: aName
    name := aName
\end{displaycode}

The instrumentation can be defined as follows, if \textcode{aName} is the reference to the value being stored in the \textcode{name} instance variable of the \textcode{Person} instance:

\begin{displaycode}{plain}
aName logCr
\end{displaycode}

The evaluation example is defined in the following script. Two instances \textcode{p1} and \textcode{p2} of class \textcode{Person} are created, and object-centric instrumentation must be applied to the \textcode{p2} instance. Then each of these instances is given a name through a call to the \textcode{name:} method. The result must be that \textcode{p2} prints its name in the \textcode{Transcript}, while nothing must happen for \textcode{p1}.

\begin{displaycode}{plain}
  |p1 p2|
  p1 := Person new.
  p2 := Person new.
  "Instrumentation must be applied to p2 here"
  p1 name: 'Worf'.
  p2 name: 'Dax'.
  "Only 'Dax' prints in the Transcript"
\end{displaycode}
\section{Evaluation criteria}
Each solution is evaluated against the following desirable properties.

\begin{tabular}{ll}
\toprule
\textbf{Property} & \textbf{Definition} \\
\midrule
Manipulated entity & The unit of instrumentation \\
 & (\textit{e.g.} a class, a Trait, an object...) \\
Reusability & The entity can be reused to instrument different objects \\
Flexibility & Instrumentation does not put constraint on the \\
 & source code or in the coding style \\
Granularity & The level of at which behavior can be instrumented \\
 & (\textit{e.g.} method, AST...) \\
Integration & Instrumentation does not break system features \\
\bottomrule
\end{tabular}
\section{Performance overhead evaluation}
To provide a approximation of the performance overhead due to instrumentation, we compare the execution time of a block of code without instrumentation with the execution time of an instrumented block of code. The method \textcode{evaluateOverheadFor:} from the following script shows how the average execution time is computed. The parameter is an instance of \textcode{Person} that is either not instrumented (\textit{i.e.} to compute the reference execution time used for comparison) or instrumented by one of the studied techniques. The \textcode{\#name:} message is sent a thousand times to the \textcode{Person} instance and each time the execution time is recorded. An average of all the execution times is computed and returned by the method. This average time is used to compare execution time of an instrumented instance against the execution time of a non-instrumented instance.

\begin{displaycode}{plain}
evaluateOverheadFor: aPerson
  |execTimes|
  execTimes := OrderedCollection new.
  1 to: 1000 do:[:i|
    execTimes add: [aPerson name: i] timeToRun].
  ^execTimes average
\end{displaycode}
\section{Structure of the book}
The second chapter will provide an overview of the evaluation results of object-centric instrumentation techniques available in Pharo. A reader may directly read this chapter if he is already familiar with the Pharo techniques presented in the book. Chapters 3 to 7 describe five solutions for object-centric instrumentation, and provide an evaluation of these solutions. Chapter 8 drafts the premises of an object-centric debugger and concludes the book.

\chapter{Summary of the overall evaluations}
If you already know Pharo and (some of) the presented technique, this chapter is a global summary with spoilers.

\chapter{Anonymous subclasses}
Anonymous classes are nameless classes that are inserted between an object and its original class \cite{foote1989reflective,hinkle1993debugging}. The object is migrated to that new class, which takes the original object's class as its superclass. Methods from the original class can be redefined and reimplemented in the anonymous class, having the effect to change the behavior of that single object. Original behavior that is not redefined in the anonymous subclass is preserved.
\section{Example}
Talents are based on traits. Objects can answer to the \textcode{\#addTalent:} messages, which takes a \textcode{Trait} as parameter. All behavior defined in the trait is flattened in the object. In the following illustration, we instantiate an anonymous trait, and we compile a method in this trait. That method is an instrumented version of the original \textcode{name} method of the class \textcode{Person}. This new method replaces the original one, until the talent is removed from the object.

\begin{displaycode}{plain}
|person anonClass|
  person := Person new.
	anonClass := anObject class newAnonymousSubclass.
	anonClass
		compile:
			'name: aName
				self tag: aName.
				name := aName'.
  "migrates the object to its new class"
	anonClass adoptInstance: person.
  "migrates back the object to its original class"
  anonClass superclass adoptInstance: person.
	^anonClass
\end{displaycode}
\section{Evaluation}
\textbf{Manipulated entity: Trait.} Behavioral variations are expressed using traits. It can be Traits defined in the image or anonymous trait instances in which specific behavior is manually compiled by the developer.

\textbf{Reusability: Yes.} A trait can be added as a Talent to any number of objects.

\textbf{Flexibility: Partial.} Using anonymous traits forces the user to manually compile code in the method. This is however necessary to achieve a sub-method granularity. Conflicts must be resolved manually when Traits are composed.

\textbf{Granularity: Method.} Traits add, remove or alter (through aliasing) the behavior of a method. It can be done at a sub-method level (\textit{e.g.} inserting a statement in the body of a method), but that requires manual rewriting of the method in the Trait.

\textbf{Integration: Partial.} The object is migrated to an anonymous subclass, which does not break system tools. However, it may break libraries that uses classes and class names as a discriminator.

\chapter{Talents}
Talents are originally behavioral units, that can be attached to an object to add, remove or alter behavior \cite{ressia2014talents}. Only the object to which a talent is attached is affected by behavioral variations. The latest talent implementationrelies on trait definition.
\section{Example}
Talents are based on traits. Objects can answer to the \textcode{\#addTalent:} messages, which takes a \textcode{Trait} as parameter. All behavior defined in the trait is flattened in the object. In the following illustration, we instantiate an anonymous trait, and we compile a method in this trait. That method is an instrumented version of the original \textcode{name} method of the class \textcode{Person}. This new method replaces the original one, until the talent is removed from the object.

\begin{displaycode}{plain}
|person talent|
  person := Person new.
	talent := Trait new.
	talent
		compile:
			'name: aName
	       self tag: aName.
	       name := aName'.
	person addTalent: talent. "adds the talent to the object"
  person removeTalent: talent. "removes the talent from the object"
\end{displaycode}
\section{Evaluation}
\textbf{Manipulated entity: Trait.} Behavioral variations are expressed using traits. It can be Traits defined in the image or anonymous trait instances in which specific behavior is manually compiled by the developer.

\textbf{Reusability: Yes.} A trait can be added as a Talent to any number of objects.

\textbf{Flexibility: Partial.} Using anonymous traits forces the user to manually compile code in the method. This is however necessary to achieve a sub-method granularity. Conflicts must be resolved manually when Traits are composed.

\textbf{Granularity: Method.} Traits add, remove or alter (through aliasing) the behavior of a method. It can be done at a sub-method level (\textit{e.g.} inserting a statement in the body of a method), but that requires manual rewriting of the method in the Trait.

\textbf{Integration: Partial.} The object is migrated to an anonymous subclass, which does not break system tools. However, it may break libraries that uses classes and class names as a discriminator.

\chapter{Proxies}\section{What are Talents}\section{Example}\subsection{Installing Talents}
aa

\begin{listing}[float, label=install]{smalltalk}{Installation from Github}

Metacello new
  baseline: 'Talents';
  repository: 'github://tesonep/pharo-talents/src';
  load.
\end{listing}
\subsection{Example}
bb

\begin{listing}[float, label=talent-example]{smalltalk}{Installation from Github}

talent := Trait named: 'MyTalent'.
talent compile: 'add: anObject
anObject logCr.
super add: anObject'.
col := OrderedCollection new.
col addTalent: talent.
col add: 'This is an added object.'
\end{listing}
\section{Evaluation}
cc

\begin{note}
this is a note annotation.
\end{note}

\begin{todo}
this is a todo annotation
\end{todo}

\begin{tabular}{ll}
\toprule
\textbf{Country} & \textbf{Capital} \\
\midrule
France & Paris \\
Belgium & Brussels \\
\textbf{Country} & \textbf{Capital} \\
\midrule
France & Paris \\
Belgium & Brussels \\
\bottomrule
\end{tabular}
\chapter{Reflectivity}
Talents \cite{ressia2014talents}is this.
\section{What are Talents}\section{Example}\subsection{Installing Talents}
aa

\begin{listing}[float, label=install]{smalltalk}{Installation from Github}

Metacello new
  baseline: 'Talents';
  repository: 'github://tesonep/pharo-talents/src';
  load.
\end{listing}
\subsection{Example}
bb

\begin{listing}[float, label=talent-example]{smalltalk}{Installation from Github}

talent := Trait named: 'MyTalent'.
talent compile: 'add: anObject
anObject logCr.
super add: anObject'.
col := OrderedCollection new.
col addTalent: talent.
col add: 'This is an added object.'
\end{listing}
\section{Evaluation}
cc

\begin{note}
this is a note annotation.
\end{note}

\begin{todo}
this is a todo annotation
\end{todo}

\begin{tabular}{ll}
\toprule
\textbf{Country} & \textbf{Capital} \\
\midrule
France & Paris \\
Belgium & Brussels \\
\textbf{Country} & \textbf{Capital} \\
\midrule
France & Paris \\
Belgium & Brussels \\
\bottomrule
\end{tabular}
\chapter{Low-level techniques}\section{Example}\subsection{Installing Talents}
aa

\begin{listing}[float, label=install]{smalltalk}{Installation from Github}

Metacello new
  baseline: 'Talents';
  repository: 'github://tesonep/pharo-talents/src';
  load.
\end{listing}
\subsection{Example}
bb

\begin{listing}[float, label=talent-example]{smalltalk}{Installation from Github}

talent := Trait named: 'MyTalent'.
talent compile: 'add: anObject
anObject logCr.
super add: anObject'.
col := OrderedCollection new.
col addTalent: talent.
col add: 'This is an added object.'
\end{listing}
\section{Evaluation}
cc

\begin{note}
this is a note annotation.
\end{note}

\begin{todo}
this is a todo annotation
\end{todo}

\begin{tabular}{ll}
\toprule
\textbf{Country} & \textbf{Capital} \\
\midrule
France & Paris \\
Belgium & Brussels \\
\textbf{Country} & \textbf{Capital} \\
\midrule
France & Paris \\
Belgium & Brussels \\
\bottomrule
\end{tabular}
\chapter{Conclusion}\section{Example}\subsection{Installing Talents}
aa

\begin{listing}[float, label=install]{smalltalk}{Installation from Github}

Metacello new
  baseline: 'Talents';
  repository: 'github://tesonep/pharo-talents/src';
  load.
\end{listing}
\subsection{Example}
bb

\begin{listing}[float, label=talent-example]{smalltalk}{Installation from Github}

talent := Trait named: 'MyTalent'.
talent compile: 'add: anObject
anObject logCr.
super add: anObject'.
col := OrderedCollection new.
col addTalent: talent.
col add: 'This is an added object.'
\end{listing}
\section{Evaluation}
cc

\begin{note}
this is a note annotation.
\end{note}

\begin{todo}
this is a todo annotation
\end{todo}

\begin{tabular}{ll}
\toprule
\textbf{Country} & \textbf{Capital} \\
\midrule
France & Paris \\
Belgium & Brussels \\
\textbf{Country} & \textbf{Capital} \\
\midrule
France & Paris \\
Belgium & Brussels \\
\bottomrule
\end{tabular}



\bibliographystyle{alpha}
\bibliography{book.bib}

% lulu requires an empty page at the end. That's why I'm using
% \backmatter here.
\backmatter

% Index would go here

\end{document}
